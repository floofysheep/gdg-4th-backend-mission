# 2주차 WIL

### 1. 객체지향
#### 1-1) 결합도와 응집도
일반적으로 좋은 소프트웨어일수록 **모듈의 독립성이 높다**고 한다. 이때 모듈의 독립성은 **결합도**와 **응집도**의 기준 단계에 따라 높고 낮음이 측정된다. 
여기서 결합도와 응집도가 무슨 의미일까?
#### 결합도
결합도는 모듈간의 상호 의존 정도를 나타낸다. 예를 들어 A 클래스가 B 클래스에 대해 너무 많은 정보를 가지고 있다면 두 클래스, 즉 두 모듈은 높은 결합도를 가지게 된다. 반면에 C 클래스가 D 클래스에 대해 정말 필요한 정보만을 가지고 있다면 낮은 결합도를 가진다고 할 수 있다. 

모듈의 독립성이 높아지려면 낮은 결합도를 가져야할 것이다.
####  응집도
응집도는 한 모듈 내의 구성요소 간의 밀접한 정도를 나타낸다. 예를 들어 한 모듈이 하나의 기능을 위한 정보들을 담고 있다면 이는 응집도가 높다고 할 수 있다. 반면에 한 모듈이 여러 기능을 위한 정보들을 담고 있다면 낮은 응집도를 가진다고 말할 수 있다. 

이때 모듈의 독립성이 높아지려면 응집도가 높아야할 것이다. 

종합해보면 **좋은 소프트웨어는 낮은 결합도와 높은 응집도를 특징으로 가져야할 것**이다.



#### 1-2) SOLID
SOLID 원칙이란 객체지향 설계에서 지켜줘야 하는 5가지 소프트웨어 개발 원칙이다.
이제부터 하나씩 살펴보자.

1️⃣ **단일 책임 원칙 - SRP (Single Responsibility Principle)**
한 클래스는 하나의 기능만을 가져 하나의 책임을 수행하는데 집중되도록 설계하라는 원칙이다. 이는 응집도를 높이고 변경에 유연하게 대처하게 하여 프로그램의 유지보수를 보다 편리하게 하는데 도움을 준다. 

2️⃣ **개방 폐쇄 원칙 - OCP (Open Closed Principle)**
확장에는 열려있어야 하며, 수정에는 닫혀있어야 한다는 원칙이다. 확장에 열려있어야 된다는 것은 변경사항이 있을 때 코드를 추가함으로 기능을 유연하게 확장할 수 있다는 것을 말한다. 수정에는 닫혀있다는 것은 변경사항이 있을 때 변경사항에 대한 직접적인 수정을 제한한다는 것을 의미한다. 

3️⃣ **리스코프 치환 원칙 - LSP (Liskov Substitution Principle)**
서브타입은 언제나 기반타입으로 교체할 수 있어야 한다는 원칙이다. 다형성을 활용하기 위함이고 상속 관계에서 일관된 행동을 보장해준다.

4️⃣ **인터페이스 분리 원칙 - ISP (Interface Segregation Principle)**
객체가 자신에게 필요한 기능만을 가지도록 제한하는 원칙이다. 즉 여러 개의 작고 명확한 인터페이스로 나누는 것이 낫다는 것을 의미한다.

5️⃣ **의존 역전 원칙 - DIP (Dependency Inversion Principle)**
어떤 클래스를 참조해야하는 상황에서 그 클래스를 직접적으로 참조하지 말고 그 대상의 상위요소를 참조하라는 원칙이다. 이는 변화가 많은 것이 아닌 적은 것에 의존하라는 것을 의미한다. 

### 2. RESTful API

#### 2-1) URL 구성요소
![](https://velog.velcdn.com/images/sheep_/post/346ec181-3e66-4520-8fcd-4aff66b78582/image.png)

- **protocol**  
어떤 방식으로 데이터를 주고받을지 정해준다.
ex) http, https, ftp 등

- **host**  
도메인 이름 또는 IP 주소를 직접 사용 가능하다.

- **port**  
어떤 포트를 통해 연결할 지를 지정한다. 일반적으로 생략 가능하다.
생략 시 http는 80, https는 443 포트 번호로 설정된다.

- **path**  
리소스 내의 파일 위치를 나타낸다. 계층적 구조로 구성된다.

- **query**  
파라미터(key=value) 형태로 데이터를 서버에 전달한다. ?로 시작되며, &로 여러개 추가 가능하다. 
ex) ?keyA=valueA&keyB=valueB

- **fragment** 
html 내부 북마크 등에 사용된다. 이는 서버에 전송하는 정보는 아니다.

#### 2-2) REST API 기본

REST API는 웹에서 **리소스**를 다루기 위한 약속된 형식의 규칙 모음이다.

REST의 핵심 구성 요소는 다음과 같다.

| 요소                      | 설명                                          |
| ----------------------- | ------------------------------------------- |
| **자원 (Resource)**       | URI로 표현됨 (`/users`, `/products/7` 등)        |
| **행위 (Verb)**           | HTTP 메서드 (`GET`, `POST`, `PUT`, `DELETE` 등) |
| **표현 (Representation)** | 주고받는 데이터 형식 (JSON, XML 등)                   |

중심 규칙 몇 가지를 살펴보면, 

**1. URI는 정보의 자원을 나타내야 한다.**  
행위에 대한 표현이 들어가서는 안된다. 이때 리소스명은 동사보다는 명사를 사용해야 한다.  

**2. HTTP 메서드를 통해 행위를 나타낸다**  
메서드	설명	예시는 다음과 같다.

| 메서드      | 설명       | 예시                |
| -------- | -------- | ----------------- |
| **`GET`**   | 자원 조회    | `GET /users`      |
| **`POST`**   | 자원 생성    | `POST /users`     |
| **`PUT`**   | 자원 전체 수정 | `PUT /users/1`    |
| **`DELETE`** | 자원 삭제    | `DELETE /users/1` |



**3. 클라이언트-서버 구조**
각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 된다.

**4. 무상태성 (Stateless)**
서버는 요청 간의 상태를 저장하지 않는다. 매 요청마다 필요한 모든 정보를 요청 본문/헤더에 포함한다.

**5. 캐시 가능**
 HTTP가 가진 캐싱 기능이 적용 가능하다. 클라이언트는 반복 요청 시 캐시된 데이터를 사용 가능하다. 

**6. 표현 계층 구조**  
클라이언트는 서버의 구조나 저장 방식에 관심 없어야 한다. 서버가 변경되어도 API는 유지된다.

위와 같다.






### 3. 클라우드 및 배포
#### 3-1) CORS
아직까지 CORS 에러를 경험해보지는 못했지만 악명높은 에러라고 한다...
경험하기 전에 대비차원에서 한번 알아보자.

CORS는 Cross-Origin Resource Sharing의 약자로 교차 출처 리소스 공유 정책이라고 해석된다. 교차 출처는 다른 출처를 말하는 것으로 URL 주소에서 Protocol(Scheme), Host, Port 이 3가지를 비교하여 하나라도 다르면 다른 출처라고 부른다. (모두 동일하면 동일 출처라고 부른다.) 

CORS는 다른 출처의 리소스 공유에 대한 허용 여부에 대한 정책이다. 이는 SOP정책을 위반하더라도 CORS 정책을 따르면 다른 출처의 리소스라도 허용 가능하다는 것을 말한다. 
> **SOP(Same-Origin Policy) 정책**은 동일한 출처에 대한 정책으로 동일한 출처에서만 리소스를 공유하게 할 수 있다.

CORS의 작동 방식에는 3가지 가능한 시나리오가 있다. 예비 요청 (Preflight Request), 단순 요청 (Simple Request), 인증된 요청 (Credentialed Request)이다. 

CORS를 해결하는 방법으로는 Chrome 확장 프로그램을 이용하거나 프록시 사이트를 이용하는 것등이 있다. 

#### 3-2) 서버리스
서버리스란 직접 서버를 관리하지 않아 신경 쓸 필요가 없는 경우를 의미한다. 
원리는 다음과 같다.

> **1.** 개발자가 서버리스에 업로드한 함수는 24시간 내내 돌아가는게 아닌 휴면 상태에 들어간다.  
**2.** 그러다가 사용자 요청이 오는 순간 서버리스는 잠들어 있는 함수를 깨우고 실행시켜 요청한 작업을 수행하게 한다. 그리고 다시 함수는 잠에 들게 한다.


서버리스는 서버 관리 없이 코드만 작성하면 클라우드가 자동으로 실행, 확장해주는 모델로 개발자는 비즈니스 로직에 집중하고, 클라우드가 나머지를 처리해준다.

장점으로는 비용이 절감되고, 서버에 신경쓸 필요가 없어지므로 애플리케이션 품질 향상을 위해 집중할 수 있다. 또한 높은 가용성과 유연한 확장 능력과 빠르게 개발 배포를 가능하게 해준다. 

물론 장점만 있는 것은 아니다. 긴 시간이 필요한 작업에는 불리하고, 로컬 데이터를 사용할 수 없으며 클라우드 제공 플랫폼에 종속적이라는 단점을 가지고 있다. 


### 🌟 마치며
전반적으로 기초적인 지식을 쌓을 수 있었다. 기존의 알고 있었던 지식과 새로 얻어간 지식을 결합해서 한 단계 더 나아갈 수 있었다. 다만 아직은 완전히 내 것으로는 만들지 못한 거 같아서 앞으로 꾸준한 학습이 필요하다고 생각했다.    


출처 : https://inpa.tistory.com/ 
